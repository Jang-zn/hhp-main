# 현재 아키텍처 분석 및 개선 방향

## 1. 개요
본 프로젝트는 모놀리식 아키텍처에서 이벤트 드리븐 아키텍처로 전환을 시도했으나, 작업이 중단된 상태입니다. 현재 상태를 분석하고 실용적인 개선 방향을 제시합니다.

## 2. 현재 아키텍처 상태

### 2.1 전체 구조
```
src/main/java/kr/hhplus/be/server/
├── adapter/           # 포트-어댑터 패턴의 어댑터 계층
│   ├── cache/         # 캐시 어댑터
│   ├── event/         # 이벤트 어댑터 (Redis Streams)
│   ├── locking/       # 분산 락 어댑터
│   └── storage/       # 저장소 어댑터
├── api/               # API 계층
│   └── controller/    # REST 컨트롤러
├── domain/            # 도메인 계층
│   ├── entity/        # 엔티티
│   ├── event/         # 도메인 이벤트
│   ├── port/          # 포트 인터페이스
│   ├── service/       # 도메인 서비스
│   └── usecase/       # 유스케이스
└── config/            # 설정
```

## 3. 현재 상태 분석

### 3.1 미완성 이벤트 드리븐 아키텍처 (작업 중단)

#### 현황
- 이벤트 드리븐 아키텍처로 전환 작업이 중단된 상태
- Redis Streams 기반 이벤트 처리 인프라는 구축되었으나 실제 비즈니스 로직 전환은 미완료
- 트랜잭션 외부에서 이벤트 발행하여 정합성 문제 가능성 존재

#### 코드 예시
```java
// OrderService.java
public Payment payOrder(Long orderId, Long userId, Long couponId) {
    // 트랜잭션 내부: 동기적 비즈니스 로직 처리
    Payment result = transactionTemplate.execute(status -> {
        // 직접적인 UseCase 호출
        Order order = validateOrderUseCase.execute(orderId, userId);
        deductBalanceUseCase.execute(userId, finalAmount);
        completeOrderUseCase.execute(order);
        return createPaymentUseCase.execute(...);
    });
    
    // 트랜잭션 외부: 이벤트 발행
    eventPort.publish(EventTopic.ORDER_COMPLETED.getTopic(), event);
    
    return result;
}
```

### 3.2 모놀리식 아키텍처의 적절한 계층 분리

#### 현황
- **Service → UseCase 계층 분리로 관심사 분리 달성**
  - Service: 트랜잭션, 분산 락 관리
  - UseCase: 비즈니스 로직, 캐싱 처리
  - 각 계층의 책임이 명확하게 구분됨

- **모놀리식에서 당연한 구조**
  - 도메인 간 직접 호출은 모놀리식에서 정상적인 패턴
  - 공유 데이터베이스 사용도 모놀리식의 특징
  - 단일 트랜잭션으로 데이터 정합성 보장 가능

#### 코드 예시
```java
// OrderService가 필요한 UseCase들을 주입받아 사용 (모놀리식에서 정상)
private final ValidateOrderUseCase validateOrderUseCase;  // Order 도메인
private final DeductBalanceUseCase deductBalanceUseCase;  // Balance 도메인  
private final ApplyCouponUseCase applyCouponUseCase;      // Coupon 도메인
```

### 3.3 이벤트 처리 시스템 (작업 중단 상태)

#### 현황
- **Redis Streams 기반 이벤트 인프라 구축됨**
  - 이벤트 기반 시스템의 복잡도는 원래 높은 것이 정상
  - RedisEventAdapter, RedisEventRouter 등 기본 구조는 완성

- **개선 필요 사항**
  - 복잡한 이벤트 타입 매칭 로직
  - 에러 처리 및 재시도 전략 부재
  - Dead Letter Queue 미구현


## 4. 실용적 개선 방향

### 4.1 기본 방침
- **모놀리식 동기 처리를 기본으로 복귀**
- **특정 케이스만 비동기 이벤트 처리 적용**

### 4.2 Kafka 적용 대상 (선별적 비동기 처리)

#### 1. 외부 시스템 연동 (EventLog)
- 현재 Mock으로 처리 중인 외부 메시지 전송
- 트랜잭션과 분리된 비동기 처리 필요
- Kafka Producer/Consumer 패턴 적용

#### 2. 선착순 쿠폰 발급
- 대용량 동시성 처리 필요
- 순서 보장과 중복 방지 필요
- Kafka의 파티션 기반 순서 보장 활용

### 4.3 구체적 작업 계획

#### Phase 1: Redis Streams 제거
1. RedisEventAdapter, RedisEventRouter 제거
2. 불필요한 이벤트 핸들러 제거
3. 도메인 서비스 내 직접 호출로 변경

#### Phase 2: Kafka 인프라 구축
1. Kafka 설정 및 Topic 생성
   - `external-events` : 외부 시스템 연동용
   - `coupon-requests` : 쿠폰 발급 요청용
2. KafkaProducer/Consumer 구현
3. 에러 처리 및 재시도 로직 구현

#### Phase 3: 선별적 비동기 처리 구현
1. EventLog용 Kafka Producer 구현
2. 선착순 쿠폰용 Kafka Consumer 구현
3. Dead Letter Queue 설정

### 4.4 현재 계층 구조 유지
- **Service (트랜잭션, 락) → UseCase (비즈니스, 캐싱) 구조는 유지**
- 각 계층의 책임이 명확하므로 현 구조 유지가 적절

## 5. 기대 효과

### 5.1 복잡도 감소
- 불필요한 이벤트 기반 구조 제거로 디버깅 용이
- 동기 처리로 실행 흐름 명확화

### 5.2 선택적 확장성
- 필요한 부분만 비동기 처리로 성능 최적화
- Kafka 적용으로 향후 확장 가능성 확보

### 5.3 유지보수성 향상
- 명확한 동기/비동기 처리 구분
- 각 도메인의 독립성 유지하면서도 단순한 구조

## 6. 결론

현재 중단된 이벤트 드리븐 아키텍처 전환 작업을 정리하고, 실용적인 접근으로 전환합니다:

1. **기본은 모놀리식 동기 처리**
2. **외부 연동과 대용량 처리만 Kafka 비동기**
3. **Service-UseCase 계층 구조는 유지**

이를 통해 불필요한 복잡도는 제거하면서도, 필요한 부분의 확장성과 성능은 확보할 수 있습니다.