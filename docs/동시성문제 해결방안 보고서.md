# 동시성 문제 해결 방안 보고서 (DB 락 중심)


## 🔍 현황 분석

### 1. 현재 동시성 제어의 문제점
현재 시스템은 메모리 기반 락(`InMemoryLockingAdapter`)과 JPA `@Version`을 통한 낙관적 락을 사용하지만, 다음과 같은 한계가 있습니다:
- **메모리 기반 락**:
  - 단일 서버 환경에서만 동작
  - 서버 재시작 시 락 상태 소실
  - 메모리 누수 가능성
- **JPA 낙관적 락**:
  - 높은 동시성 환경에서 충돌 빈발
  - 복잡한 비즈니스 로직에 부적합
  - 재시도 로직 추가 필요

### 2. 주요 동시성 문제 시나리오
1. **상품 재고 초과 주문**:
   - 여러 사용자가 동시에 재고 확인 후 예약 시, 레이스 컨디션으로 재고 초과 예약 발생
   - 예: 재고 10개인 상품에 두 사용자가 각각 8개 주문 → 16개 예약
2. **쿠폰 발급량 초과**:
   - 한정 수량 쿠폰에 동시 요청 시, 발급 한도 초과
   - 예: 100개 제한 쿠폰에 105개 발급
3. **잔액 부족 동시 결제**:
   - 잔액 확인 후 차감 중 레이스 컨디션으로 음수 잔액 발생
   - 예: 1000원 잔액에 두 개의 800원 결제 → -600원 잔액

## 🎯 DB 기반 동시성 제어 해결 방안

### 1. 비관적 락(Pessimistic Lock)
비관적 락을 통해 특정 리소스에 대한 동시 접근을 차단하고 데이터 일관성을 보장합니다. 배타 락을 사용합니다.

#### 1.1 상품 재고 관리
**개선 방안**:
- **`SELECT ... FOR UPDATE` 활용**:
  - JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)`로 배타 락을 걸어 재고 조회 및 업데이트를 원자적으로 처리
  - 락 타임아웃 설정으로 무한 대기 방지
- **JPA 제약 조건**:
  - `@Check` 어노테이션으로 재고 및 예약 재고가 음수로 가지 않도록 제약
  - 예약 재고가 실제 재고를 초과하지 않도록 제약

```java
// 개선된 Product Repository
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints(@QueryHint(name = "javax.persistence.lock.timeout", value = "3000"))
    @Query("SELECT p FROM Product p WHERE p.id = :productId")
    Optional<Product> findByIdWithLock(@Param("productId") Long productId);
}

// 개선된 Product 엔티티
@Entity
@Table(name = "product")
@Check(constraints = {
    "stock >= 0",
    "reserved_stock >= 0",
    "reserved_stock <= stock"
})
public class Product {
    @Column(nullable = false)
    @Min(value = 0)
    private int stock;

    @Column(name = "reserved_stock", nullable = false)
    @Min(value = 0)
    private int reservedStock;

    public void reserveStock(int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("수량은 0보다 커야 합니다");
        }
        if (this.stock - this.reservedStock < quantity) {
            throw new ProductException.OutOfStock();
        }
        this.reservedStock += quantity;
    }
}

// 개선된 UseCase
@UseCase
public class ReserveProductStockUseCase {
    private final ProductRepository productRepository;

    @Transactional
    public void reserveStock(Long productId, int quantity) {
        Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new ProductException.NotFound());
        product.reserveStock(quantity);
        // JPA @Check 제약 조건이 추가 검증 수행
    }
}
```

#### 1.2 쿠폰 발급 한도 관리
**개선 방안**:
- **비관적 락 활용**:
  - 배타 락으로 쿠폰 발급 시 동시 접근 제어
  - 높은 동시성에서 락 경합을 줄이기 위해 짧은 트랜잭션 유지
- **JPA 제약 조건**:
  - `@Check` 어노테이션으로 발급 수량이 최대 한도를 초과하지 않도록 제약
- **중복 발급 방지**:
  - 애플리케이션 레벨에서 쿠폰 히스토리 조회로 중복 발급 방지

```java
// 개선된 Coupon Repository
@Repository
public interface CouponRepository extends JpaRepository<Coupon, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints(@QueryHint(name = "javax.persistence.lock.timeout", value = "3000"))
    @Query("SELECT c FROM Coupon c WHERE c.id = :couponId")
    Optional<Coupon> findByIdWithLock(@Param("couponId") Long couponId);
}

// 개선된 Coupon 엔티티
@Entity
@Table(name = "coupon")
@Check(constraints = "issued_count <= max_issuance")
public class Coupon {
    @Column(name = "max_issuance", nullable = false)
    private Integer maxIssuance;

    @Column(name = "issued_count", nullable = false)
    private Integer issuedCount = 0;

    public void issue() {
        if (this.issuedCount >= this.maxIssuance) {
            throw new CouponException.CouponStockExceeded();
        }
        this.issuedCount += 1;
    }
}

// 개선된 UseCase
@UseCase
public class IssueCouponUseCase {
    private final CouponRepository couponRepository;
    private final CouponHistoryRepository couponHistoryRepository;

    @Transactional
    public void issueCoupon(Long userId, Long couponId) {
        // 애플리케이션 레벨 중복 발급 방지
        if (couponHistoryRepository.existsByUserIdAndCouponId(userId, couponId)) {
            throw new CouponException.AlreadyIssued();
        }
        Coupon coupon = couponRepository.findByIdWithLock(couponId)
            .orElseThrow(() -> new CouponException.NotFound());
        coupon.issue();
        couponHistoryRepository.save(
            CouponHistory.builder()
                .userId(userId)
                .couponId(couponId)
                .status(CouponStatus.ISSUED)
                .build()
        );
    }
}
```

### 2. 낙관적 락(Optimistic Lock)
낙관적 락은 충돌 가능성이 낮은 경우 적합하며, `@Version`으로 버전 관리합니다.

#### 2.1 잔액 관리
**개선 방안**:
- **버전 관리**:
  - `@Version`으로 충돌 감지 후 Spring Retry로 재시도
- **JPA 제약 조건**:
  - `@Check` 어노테이션으로 잔액 음수 방지

```java
// 개선된 Balance 엔티티
@Entity
@Table(name = "balances")
@Check(constraints = "amount >= 0")
public class Balance {
    @Version
    private Long version;

    @Column(nullable = false, precision = 19, scale = 2)
    @DecimalMin("0.00")
    private BigDecimal amount;

    public void subtractAmount(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("차감 금액은 0보다 커야 합니다");
        }
        if (this.amount.compareTo(amount) < 0) {
            throw new BalanceException.InsufficientBalance();
        }
        this.amount = this.amount.subtract(amount);
    }
}

// 개선된 UseCase
@UseCase
public class DeductBalanceUseCase {
    private final BalanceRepository balanceRepository;

    @Transactional
    @Retryable(retryFor = OptimisticLockingFailureException.class, maxAttempts = 3)
    public void deductBalance(Long userId, BigDecimal amount) {
        Balance balance = balanceRepository.findByUserId(userId)
            .orElseThrow(() -> new BalanceException.NotFound());
        balance.subtractAmount(amount);
        // JPA @Check 제약 조건이 추가 검증 수행
    }
}
```

### 3. 데드락 방지 전략
**개선 방안**:
- **락 순서 표준화**:
  - 다중 리소스 락 획득 시 ID 정렬
- **타임아웃 설정**:
  - 락 대기 시간 제한
- **트랜잭션 분리**:
  - 긴 트랜잭션 분할로 락 유지 시간 최소화

```java
@Component
public class LockOrderManager {
    public List<Long> getOrderedLockIds(List<Long> resourceIds) {
        return resourceIds.stream().distinct().sorted().collect(Collectors.toList());
    }
}

@UseCase
public class PayOrderUseCase {
    private final LockOrderManager lockOrderManager;
    private final ProductRepository productRepository;
    private final BalanceRepository balanceRepository;

    @Transactional
    public void payOrder(Long orderId, Long userId, List<Long> productIds) {
        List<Long> orderedIds = lockOrderManager.getOrderedLockIds(productIds);
        List<Product> products = productRepository.findByIdsWithLock(orderedIds);
        Balance balance = balanceRepository.findByUserIdWithLock(userId)
            .orElseThrow(() -> new BalanceException.NotFound());
        // 비즈니스 로직 수행
    }
}
```

### 4. JPA 기반 제약 조건
**개선 방안**:
- **JPA `@Check` 어노테이션**:
  - 상품, 쿠폰, 잔액의 데이터 무결성을 JPA 엔티티 수준에서 보장
- **애플리케이션 레벨 검증**:
  - 쿠폰 히스토리 조회로 중복 발급 방지

```java
@Entity
@Table(name = "product")
@Check(constraints = {
    "stock >= 0",
    "reserved_stock >= 0",
    "reserved_stock <= stock"
})
public class Product {
    // ... (위 Product 엔티티와 동일)
}

@Entity
@Table(name = "coupon")
@Check(constraints = "issued_count <= max_issuance")
public class Coupon {
    // ... (위 Coupon 엔티티와 동일)
}

@Entity
@Table(name = "balances")
@Check(constraints = "amount >= 0")
public class Balance {
    // ... (위 Balance 엔티티와 동일)
}
```

### 5. 추가 DB 레벨 접근 방안
#### 5.1 트랜잭션 타임아웃 설정
- **설명**:
  - 트랜잭션 실행 시간을 제한하여 장기 실행으로 인한 DB 부하 감소
  - 예: `@Transactional(timeout = 5)`로 5초 제한
- **사용 사례**:
  - 재고 차감, 잔액 업데이트 등에서 타임아웃 초과 시 롤백
- **장점**:
  - 커넥션 풀 고갈 방지
  - 데드락 위험 감소

```java
@UseCase
public class ReserveProductStockUseCase {
    private final ProductRepository productRepository;

    @Transactional(timeout = 5)
    public void reserveStock(Long productId, int quantity) {
        Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new ProductException.NotFound());
        product.reserveStock(quantity);
    }
}
```

#### 5.2 LazyConnectionDataSourceProxy 적용
- **설명**:
  - Spring의 `LazyConnectionDataSourceProxy`를 사용하여 DB 연결을 쿼리 실행 시점까지 지연
  - 트랜잭션 시작 시 연결을 획득하지 않고, 실제 SQL 실행(`Statement` 생성) 직전에 연결을 가져옴
  - 트랜잭션 범위를 최소화하여 연결 풀 점유 시간 감소
- **사용 사례**:
  - 트랜잭션 내 외부 API 호출(예: 결제 게이트웨이, 배송 API) 또는 캐시 조회(Redis) 후 DB 쿼리 실행 시 연결 지연
  - 읽기 전용 트랜잭션에서 2차 캐시 히트 시 연결 획득 방지
- **장점**:
  - 연결 풀 고갈 위험 감소
  - 트랜잭션 응답 시간 단축
- **구현 예시**:
```java
@Configuration
public class DataSourceConfig {
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.hikari")
    public HikariDataSource hikariDataSource() {
        return new HikariDataSource();
    }

    @Bean
    public DataSource dataSource(HikariDataSource hikariDataSource) {
        return new LazyConnectionDataSourceProxy(hikariDataSource);
    }

    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

@Service
public class OrderService {
    private final ProductRepository productRepository;

    @Transactional(readOnly = true)
    public Product getProduct(Long productId) {
        // 외부 API 호출 (500ms 소요)
        Thread.sleep(500);
        // LazyConnectionDataSourceProxy로 연결은 여기서 획득
        return productRepository.findById(productId).orElseThrow();
    }
}
```

### 6. 추가 학습 후 적용 검토할 DB 레벨 개선사항
- **파티셔닝 활용**:
  - 상품, 쿠폰 테이블을 시간 또는 ID 범위로 파티셔닝하여 락 경합 감소
  - 예: `PARTITION BY RANGE (id)`로 데이터 분할
  - 장점: 대규모 데이터 환경에서 동시성 성능 향상
- **쿼리 힌트 활용**:
  - MySQL 쿼리 힌트(예: `FORCE INDEX`, `STRAIGHT_JOIN`)를 사용해 락 관련 쿼리 최적화
  - 예: `SELECT /*+ INDEX(product idx_stock) */ ... FOR UPDATE`
  - 장점: 락 획득 속도 개선 가능

## 📋 결론
현재 시스템은 메모리 기반 락의 단일 서버 제약과 낙관적 락의 충돌 빈발 문제로 인해 재고 초과, 쿠폰 초과 발급, 잔액 음수 등의 동시성 문제가 발생하고 있습니다. 이를 해결하기 위해 DB 레벨에서 배타 락, 낙관적 락, JPA `@Check` 제약 조건, 트랜잭션 타임아웃 설정, MVCC 최적화를 활용하며, `LazyConnectionDataSourceProxy`를 적용해 DB 연결을 지연시키고 트랜잭션 범위를 최소화하여 연결 풀 효율성을 높이기로 했습니다. 추가로 파티셔닝과 쿼리 힌트를 검토하여 지속적인 개선을 추진할 계획입니다.
