# Kafka Factory 패턴 학습 가이드

## 📋 개요

Spring Kafka에서 Factory 패턴은 Kafka Consumer와 Producer를 생성하고 구성하는 핵심 메커니즘입니다. 이 문서에서는 Factory 패턴이 왜 필요한지, 사용하지 않을 때의 문제점, 그리고 Factory 패턴으로 해결할 수 있는 문제들을 상세히 설명합니다.

## 🎯 Factory 패턴을 사용해야 하는 이유

### 1. 구성(Configuration)의 중앙화와 일관성

**Factory 패턴 없이:**
```java
// 각 Consumer마다 개별적으로 구성 - 일관성 없음
@Component
public class OrderConsumer {
    
    @KafkaListener(topics = "order-completed")
    public void handleOrder(ConsumerRecord<String, String> record) {
        // 매번 다른 설정으로 Consumer가 생성될 수 있음
        // 직렬화/역직렬화 설정이 불일치할 수 있음
        ObjectMapper mapper = new ObjectMapper(); // 매번 새로운 인스턴스
        // ...
    }
}
```

**Factory 패턴 사용:**
```java
@Configuration
public class KafkaConfig {
    
    // 모든 Consumer가 동일한 설정을 공유
    @Bean
    public ConsumerFactory<String, OrderCompletedEvent> orderCompletedConsumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        props.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, OrderCompletedEvent.class);
        props.put(JsonDeserializer.TRUSTED_PACKAGES, "kr.hhplus.be.server.domain.event");
        
        return new DefaultKafkaConsumerFactory<>(props);
    }
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> 
            orderCompletedKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(orderCompletedConsumerFactory());
        factory.setConcurrency(3); // 모든 Consumer가 동일한 동시성 설정
        return factory;
    }
}
```

### 2. 타입 안정성 (Type Safety)

**Factory 패턴 없이:**
```java
@KafkaListener(topics = "order-completed")
public void handleOrder(ConsumerRecord<String, Object> record) {
    // 런타임에 타입 캐스팅 필요 - ClassCastException 위험
    try {
        OrderCompletedEvent event = (OrderCompletedEvent) record.value();
        // 타입 불일치 시 런타임 에러
    } catch (ClassCastException e) {
        // 타입 안정성 문제로 인한 에러 처리 필요
    }
}
```

**Factory 패턴 사용:**
```java
@KafkaListener(topics = "order-completed", 
               containerFactory = "orderCompletedKafkaListenerContainerFactory")
public void handleOrder(OrderCompletedEvent event) {
    // 컴파일 타임에 타입 안정성 보장
    // event는 이미 올바른 타입으로 역직렬화됨
    Long orderId = event.getOrderId(); // 안전한 접근
}
```

### 3. 에러 처리의 표준화

**Factory 패턴 없이:**
```java
@KafkaListener(topics = "order-completed")
public void handleOrder(ConsumerRecord<String, String> record) {
    try {
        ObjectMapper mapper = new ObjectMapper();
        OrderCompletedEvent event = mapper.readValue(record.value(), OrderCompletedEvent.class);
        // 각 Consumer마다 개별적인 에러 처리 로직
    } catch (JsonProcessingException e) {
        // 일관되지 않은 에러 처리
        log.error("역직렬화 실패: {}", e.getMessage());
        // 메시지 손실 위험
    }
}
```

**Factory 패턴 사용:**
```java
// Factory에서 ErrorHandlingDeserializer 설정
props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
props.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);

// Consumer에서는 비즈니스 로직에만 집중
@KafkaListener(topics = "order-completed", 
               containerFactory = "orderCompletedKafkaListenerContainerFactory")
public void handleOrder(OrderCompletedEvent event) {
    // 역직렬화 에러는 Factory 레벨에서 자동 처리
    // Dead Letter Topic으로 자동 라우팅 가능
    processOrder(event);
}
```

## 🚫 Factory 패턴을 사용하지 않을 때의 문제점

### 1. 설정 중복과 불일치 문제

```java
// 문제가 있는 코드 - 각 Consumer마다 다른 설정
@Component
public class OrderConsumer {
    @KafkaListener(topics = "order-completed")
    public void handleOrder(ConsumerRecord<String, String> record) {
        // Consumer A: Jackson ObjectMapper 사용
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
}

@Component
public class PaymentConsumer {
    @KafkaListener(topics = "payment-completed")
    public void handlePayment(ConsumerRecord<String, String> record) {
        // Consumer B: 다른 ObjectMapper 설정 사용
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);
        // 동일한 이벤트 구조라도 다르게 처리될 수 있음
    }
}
```

### 2. 메모리 및 성능 문제

```java
// 문제가 있는 코드 - 리소스 낭비
@KafkaListener(topics = "order-completed")
public void handleOrder(ConsumerRecord<String, String> record) {
    // 메시지 처리할 때마다 새로운 ObjectMapper 인스턴스 생성
    ObjectMapper mapper = new ObjectMapper(); // 메모리 낭비
    
    // Consumer 설정도 매번 새롭게 처리
    // 커넥션 풀링 없음 - 성능 저하
}
```

### 3. 에러 처리 표준화 부재

```java
// 문제가 있는 코드 - 일관되지 않은 에러 처리
@Component
public class InconsistentErrorHandling {
    
    @KafkaListener(topics = "order-completed")
    public void handleOrder(ConsumerRecord<String, String> record) {
        try {
            // Consumer A: 에러 시 로그만 출력
            ObjectMapper mapper = new ObjectMapper();
            OrderCompletedEvent event = mapper.readValue(record.value(), OrderCompletedEvent.class);
        } catch (Exception e) {
            log.error("Order processing failed", e);
            // 메시지 손실
        }
    }
    
    @KafkaListener(topics = "payment-completed")
    public void handlePayment(ConsumerRecord<String, String> record) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            PaymentCompletedEvent event = mapper.readValue(record.value(), PaymentCompletedEvent.class);
        } catch (Exception e) {
            log.error("Payment processing failed", e);
            throw e; // Consumer B: 예외를 다시 던짐 - 재시도 무한반복 위험
        }
    }
}
```

## ✅ Factory 패턴으로 개선할 수 있는 문제들

### 1. 구성 관리의 중앙화

```java
@Configuration
public class KafkaConfig {
    
    // 공통 설정을 한 곳에서 관리
    private Map<String, Object> getCommonConsumerProps() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "default-group");
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return props;
    }
    
    // 타입별 특화된 Factory
    @Bean
    public ConsumerFactory<String, OrderCompletedEvent> orderCompletedConsumerFactory() {
        Map<String, Object> props = getCommonConsumerProps();
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        props.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, OrderCompletedEvent.class);
        return new DefaultKafkaConsumerFactory<>(props);
    }
}
```

### 2. 성능 최적화

```java
@Configuration
public class OptimizedKafkaConfig {
    
    // 커넥션 풀링과 리소스 재사용
    @Bean
    public ConsumerFactory<String, OrderCompletedEvent> orderCompletedConsumerFactory() {
        Map<String, Object> props = new HashMap<>();
        // ... 기본 설정
        
        // 커넥션 풀 설정
        props.put(ConsumerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG, 300000);
        props.put(ConsumerConfig.METADATA_MAX_AGE_CONFIG, 300000);
        
        // 배치 처리 최적화
        props.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, 1024);
        props.put(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, 500);
        
        return new DefaultKafkaConsumerFactory<>(props);
    }
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> 
            orderCompletedKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(orderCompletedConsumerFactory());
        
        // 동시성 최적화
        factory.setConcurrency(3);
        factory.setBatchListener(true); // 배치 처리 활성화
        
        return factory;
    }
}
```

### 3. 모니터링과 메트릭 수집

```java
@Configuration
public class MonitoringKafkaConfig {
    
    @Bean
    public ConsumerFactory<String, OrderCompletedEvent> orderCompletedConsumerFactory() {
        Map<String, Object> props = new HashMap<>();
        // ... 기본 설정
        
        // 메트릭 수집 활성화
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);
        props.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed");
        
        return new DefaultKafkaConsumerFactory<>(props);
    }
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> 
            orderCompletedKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(orderCompletedConsumerFactory());
        
        // 에러 핸들링과 모니터링
        factory.setErrorHandler(new SeekToCurrentErrorHandler(
            new FixedBackOff(1000L, 3))); // 재시도 정책
        
        // 컨테이너 이벤트 리스너 추가
        factory.setContainerCustomizer(container -> {
            container.setupMessageListener((MessageListener<String, OrderCompletedEvent>) record -> {
                // 메시지 처리 전 메트릭 수집
                Metrics.counter("kafka.message.received", "topic", record.topic()).increment();
            });
        });
        
        return factory;
    }
}
```

## 🎯 실제 프로젝트 적용 예시

### 현재 프로젝트의 Factory 구성

```java
@Configuration
@EnableKafka
public class KafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;
    
    // 주문 완료 이벤트 Consumer Factory
    @Bean
    public ConsumerFactory<String, OrderCompletedEvent> orderCompletedConsumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "order-ranking-group");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        props.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        props.put(JsonDeserializer.VALUE_DEFAULT_TYPE, OrderCompletedEvent.class);
        props.put(JsonDeserializer.TRUSTED_PACKAGES, "kr.hhplus.be.server.domain.event");
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        
        return new DefaultKafkaConsumerFactory<>(props);
    }
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> 
            orderCompletedKafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, OrderCompletedEvent> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(orderCompletedConsumerFactory());
        factory.setConcurrency(3);
        return factory;
    }
    
    // 이벤트 Consumer에서 사용
    @KafkaListener(topics = "order-completed", 
                   containerFactory = "orderCompletedKafkaListenerContainerFactory")
    public void handleOrderCompleted(OrderCompletedEvent event) {
        // 타입 안정성 보장된 이벤트 처리
        // 에러 처리는 Factory 레벨에서 표준화됨
        // 성능 최적화된 Consumer 사용
    }
}
```

## 📊 Factory 패턴 사용 효과

### Before vs After 비교

| 구분 | Factory 패턴 없음 | Factory 패턴 사용 |
|------|------------------|-------------------|
| **타입 안정성** | 런타임 캐스팅 필요 | 컴파일 타임 보장 |
| **설정 일관성** | Consumer마다 다름 | 중앙에서 통일 관리 |
| **에러 처리** | 개별적으로 구현 | 표준화된 처리 |
| **성능** | 매번 새 인스턴스 생성 | 재사용과 최적화 |
| **유지보수** | 분산된 설정 관리 | 중앙화된 관리 |
| **테스트** | 각각 별도 설정 필요 | 통합된 테스트 가능 |

## 💡 결론

Factory 패턴은 Spring Kafka에서 다음과 같은 핵심 가치를 제공합니다:

1. **중앙화된 구성 관리**: 모든 Kafka Consumer/Producer 설정을 한 곳에서 관리
2. **타입 안정성**: 컴파일 타임에 타입 체크로 런타임 에러 방지
3. **성능 최적화**: 리소스 재사용과 커넥션 풀링으로 성능 향상
4. **표준화된 에러 처리**: 일관된 에러 처리 정책으로 안정성 증대
5. **유지보수성 향상**: 설정 변경 시 한 곳만 수정하면 전체 적용

Factory 패턴 없이는 분산되고 일관되지 않은 설정으로 인해 예측하기 어려운 문제들이 발생할 수 있으며, 이는 시스템의 안정성과 성능에 직접적인 영향을 미칩니다. 따라서 Spring Kafka를 사용할 때는 반드시 Factory 패턴을 활용하여 체계적이고 표준화된 이벤트 처리 시스템을 구축해야 합니다.