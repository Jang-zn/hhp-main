# Kafka JsonDeserializer/JsonSerializer 학습자료

## 1. 개요

Spring Kafka에서 JSON 기반 메시지 직렬화/역직렬화는 복잡한 객체를 Kafka를 통해 전송하기 위한 핵심 메커니즘입니다. 이 문서는 실제 프로젝트에서 발생한 문제들을 바탕으로 JsonDeserializer와 JsonSerializer의 동작 원리와 해결책을 설명합니다.

## 2. JsonSerializer/JsonDeserializer 동작 원리

### 2.1 JsonSerializer
```java
// KafkaConfig.java에서의 JsonSerializer 설정
JsonSerializer<Object> valueSerializer = new JsonSerializer<>(kafkaObjectMapper);
```

JsonSerializer는 Java 객체를 JSON 문자열로 변환합니다:
1. **타입 정보 헤더 추가**: 기본적으로 `__TypeId__` 헤더에 클래스 정보를 포함
2. **Jackson ObjectMapper 사용**: 설정된 ObjectMapper를 통해 JSON 직렬화 수행
3. **바이트 배열 변환**: JSON 문자열을 바이트 배열로 변환하여 Kafka에 전송

### 2.2 JsonDeserializer
```java
// 문제가 발생했던 기본 설정
props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
```

JsonDeserializer는 JSON 문자열을 Java 객체로 복원합니다:
1. **타입 정보 확인**: 메시지 헤더에서 타입 정보를 찾음
2. **타입 정보 없을 경우**: `Object.class`로 역직렬화 → **LinkedHashMap 생성**
3. **Jackson ObjectMapper 사용**: JSON을 지정된 타입으로 역직렬화

## 3. 프로젝트에서 발생한 문제

### 3.1 문제 상황
```java
// CouponRequestConsumer.java에서 발생한 ClassCastException
@KafkaListener(topics = "coupon-requests", containerFactory = "couponKafkaListenerContainerFactory")
public void handleCouponRequest(CouponRequestEvent event, Acknowledgment ack) {
    // 실제로는 LinkedHashMap이 전달되어 ClassCastException 발생
}
```

**에러 메시지**:
```
java.lang.ClassCastException: 
class java.util.LinkedHashMap cannot be cast to class 
kr.hhplus.be.server.domain.event.CouponRequestEvent
```

### 3.2 원인 분석
1. **타입 정보 헤더 비활성화**: `JsonDeserializer.USE_TYPE_INFO_HEADERS = false`로 설정
2. **기본 타입으로 역직렬화**: 타입 정보가 없어서 `Object.class`로 역직렬화
3. **LinkedHashMap 생성**: Jackson이 JSON 객체를 LinkedHashMap으로 변환
4. **타입 캐스팅 실패**: LinkedHashMap을 CouponRequestEvent로 캐스팅 시도하여 예외 발생

## 4. 해결책 및 대안

### 4.1 해결책 1: TYPE_MAPPINGS 사용 (현재 적용)
```java
// KafkaConfig.java
props.put(JsonDeserializer.TYPE_MAPPINGS, 
    "coupon-requests:kr.hhplus.be.server.domain.event.CouponRequestEvent," +
    "coupon-results:kr.hhplus.be.server.domain.event.CouponResultEvent," +
    "product.created:kr.hhplus.be.server.domain.event.ProductUpdatedEvent," +
    "product.updated:kr.hhplus.be.server.domain.event.ProductUpdatedEvent," +
    "product.deleted:kr.hhplus.be.server.domain.event.ProductUpdatedEvent");
```

**장점**:
- 토픽별로 명시적 타입 지정 가능
- 타입 정보 헤더 없이도 올바른 객체 생성

**단점**:
- 토픽과 타입을 수동으로 매핑해야 함
- 새로운 이벤트 타입 추가 시 설정 업데이트 필요

### 4.2 해결책 2: Type Headers 활성화
```java
// 타입 헤더를 사용하는 방식
props.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
```

**장점**:
- 동적 타입 해석 가능
- 설정 업데이트 불필요

**단점**:
- 보안 위험 (TRUSTED_PACKAGES = "*")
- Producer와 Consumer 간 헤더 정보 일치 필요

### 4.3 해결책 3: 토픽별 Consumer Factory
```java
@Bean
public ConcurrentKafkaListenerContainerFactory<String, CouponRequestEvent> 
    couponRequestKafkaListenerContainerFactory() {
    // 쿠폰 요청 전용 Consumer Factory
}
```

**장점**:
- 타입 안정성 보장
- 토픽별 독립적인 설정 가능

**단점**:
- 범용성 감소
- 설정 복잡도 증가

### 4.4 해결책 4: Custom Deserializer
```java
public class EventDeserializer extends JsonDeserializer<Object> {
    @Override
    public Object deserialize(String topic, byte[] data) {
        // 토픽 기반 동적 타입 결정 로직
        Class<?> targetType = getTargetTypeByTopic(topic);
        return objectMapper.readValue(data, targetType);
    }
}
```

**장점**:
- 완전한 제어 가능
- 복잡한 비즈니스 로직 적용 가능

**단점**:
- 구현 복잡도 높음
- 유지보수 부담 증가

## 5. 직렬화/역직렬화 모범 사례

### 5.1 Jackson ObjectMapper 설정
```java
@Bean
public ObjectMapper kafkaObjectMapper() {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    return mapper;
}
```

### 5.2 JSON 직렬화 제외 처리
```java
public class CouponRequestEvent {
    @JsonIgnore  // 계산된 속성은 직렬화에서 제외
    public String getPartitionKey() {
        return "user:" + userId;
    }
}
```

### 5.3 안전한 타입 매핑
```java
// 패키지 기반 신뢰 설정
props.put(JsonDeserializer.TRUSTED_PACKAGES, "kr.hhplus.be.server.domain.event");
```

## 6. 트러블슈팅 가이드

### 6.1 ClassCastException 발생 시
1. **타입 정보 확인**: 메시지 헤더에 `__TypeId__` 존재 여부 확인
2. **TYPE_MAPPINGS 점검**: 토픽과 클래스 매핑이 올바른지 확인
3. **TRUSTED_PACKAGES 검증**: 패키지 경로가 정확한지 확인

### 6.2 JSON 직렬화 오류 시
1. **@JsonIgnore 적용**: 직렬화하지 않을 메서드에 어노테이션 추가
2. **ObjectMapper 설정**: 날짜 처리 등 특수 타입 설정 확인
3. **순환 참조 확인**: 객체 그래프에서 순환 참조 존재 여부 점검

### 6.3 성능 최적화
1. **객체 재사용**: ObjectMapper 인스턴스 재사용
2. **타입 캐싱**: 자주 사용되는 타입 정보 캐싱
3. **배치 처리**: 대량 메시지 처리 시 배치 단위 설정

## 7. 결론

Kafka의 JSON 직렬화/역직렬화는 메시지 기반 아키텍처의 핵심 구성 요소입니다. 타입 안정성과 성능을 모두 고려한 설정을 통해 안정적인 이벤트 처리 시스템을 구축할 수 있습니다.

**권장 접근법**:
1. **개발 초기**: TYPE_MAPPINGS를 통한 명시적 타입 매핑
2. **시스템 확장**: Custom Deserializer를 통한 유연한 타입 처리
3. **운영 환경**: 모니터링과 함께 성능 최적화 적용

이러한 접근을 통해 확장 가능하고 유지보수가 용이한 Kafka 이벤트 시스템을 구축할 수 있습니다.