# Redis vs Kafka 역할 차이 학습 자료
## "뭐든 빠르게" vs "메시징 확실하게"의 진짜 차이

## 1. 핵심 질문: 왜 둘 다 필요한가?

### 1.1 시간축으로 생각해보기

당신이 쇼핑몰에서 "주문하기" 버튼을 눌렀다고 생각해보세요.

**🚨 즉시 일어나야 하는 일들 (사용자가 기다림)**
- "주문이 접수되었습니다" 메시지 → 0.5초 내에
- 중복 클릭 방지 → 바로 차단되어야 함
- 재고 확인 → "품절입니다" 즉시 알려줘야 함
- 로그인 세션 확인 → 바로

**⏰ 나중에 해도 되는 일들 (사용자는 안 기다림)**
- 주문 확인 이메일 발송 → 5분 늦어도 OK
- 재고 시스템 업데이트 → 1분 늦어도 OK  
- 배송 시스템에 알림 → 10분 늦어도 OK
- 추천 시스템 데이터 수집 → 하루 늦어도 OK

**바로 이게 Redis와 Kafka의 역할 분담입니다!**

- **Redis**: 첫 번째 그룹 (즉시성)
- **Kafka**: 두 번째 그룹 (안정성)

### 1.2 근본적인 설계 철학 차이

**Redis: "사용자 경험 최우선"**
- 모든 데이터를 메모리에 올려놓고 초고속 처리
- 0.1ms 응답 시간이 목표
- 임시 데이터여도 상관없음 (서버 재시작하면 사라져도 됨)
- 사용자가 "빠르다"고 느끼게 하는 것이 목적

**Kafka: "시스템 안정성 최우선"**  
- 모든 메시지를 디스크에 순서대로 영구 저장
- 10ms 응답 시간도 OK, 대신 절대 잃어버리면 안 됨
- 서버가 죽어도 데이터는 살아있어야 함
- 시스템이 "안정적으로" 동작하게 하는 것이 목적

## 2. Redis - "지금 당장" 전문가

### 2.1 언제 Redis를 쓸까?

**상황 1: 사용자가 기다리고 있을 때**

상품 페이지를 클릭했는데 3초 동안 로딩된다면? 사용자는 떠납니다.
DB에서 매번 상품 정보를 조회하면 평균 50ms 걸립니다.
하루에 1만 번 조회되는 상품이라면? 50ms × 1만 = 8.3분의 DB 시간!

Redis 캐시를 쓰면:
- 첫 번째 조회: DB에서 가져와서 Redis에 저장 (50ms)
- 나머지 9,999번 조회: Redis에서 바로 (0.5ms × 9,999 = 5초)
- 총 시간: 50ms + 5초 = 약 5초 (기존 8.3분 → 5초로 단축!)

```java
// Redis 캐시 사용법
@Cacheable(value = "products", key = "#productId")
public Product getProduct(Long productId) {
    // 캐시에 없으면 DB 조회 후 자동으로 Redis에 저장
    return productRepository.findById(productId);
}
```

**상황 2: 동시성 문제가 있을 때**

선착순 쿠폰 이벤트에서 100명이 동시에 쿠폰을 받으려고 합니다. 쿠폰은 10개뿐.
DB만 쓰면? → 동시성 문제로 11개, 12개가 발급될 수 있음

Redis 분산 락을 쓰면:
- 100명이 동시에 요청해도 한 번에 한 명씩만 쿠폰 발급 로직 실행
- 10명이 쿠폰 받으면 나머지 90명은 "품절" 메시지
- 전체 처리 시간: 1초 내 완료

```java
// Redis 분산 락 사용법
public boolean issueCoupon(Long userId, Long couponId) {
    RLock lock = redissonClient.getLock("coupon:" + couponId);
    try {
        if (lock.tryLock(1, TimeUnit.SECONDS)) {
            // 오직 한 명만 여기 들어올 수 있음
            return couponService.issueIfAvailable(userId, couponId);
        }
        return false; // 다른 사람이 처리 중
    } finally {
        lock.unlock();
    }
}
```

**상황 3: 임시 데이터를 빠르게 저장/조회할 때**

로그인하지 않은 사용자의 장바구니:
- DB에 저장하기엔 너무 임시적 (대부분 구매 안 함)
- 하지만 페이지 새로고침해도 유지되어야 함
- 2시간 후엔 자동으로 사라져도 됨

Redis의 TTL(만료 시간) 기능이 완벽:
- 빠른 저장/조회 (0.1ms)
- 자동 만료 (2시간 후 삭제)
- 메모리 효율적 관리

```java
// Redis TTL 사용법
public void addToCart(String sessionId, CartItem item) {
    redisTemplate.opsForList().leftPush("cart:" + sessionId, item);
    // 2시간 후 자동 삭제
    redisTemplate.expire("cart:" + sessionId, Duration.ofHours(2));
}
```

### 2.2 Redis의 한계

**문제 1: 서버 재시작하면 데이터 날아감**
- 메모리 기반이라 휘발성
- 중요한 데이터는 Redis만으로 부족

**문제 2: 메모리 용량 제한**
- 모든 데이터를 메모리에 올릴 수 없음
- 비용이 많이 듦

**문제 3: 복잡한 쿼리 불가**
- 단순한 키-값 조회만 가능
- JOIN이나 복잡한 검색 불가

## 3. Kafka - "확실하게" 전문가

### 3.1 언제 Kafka를 쓸까?

**상황 1: 절대 놓치면 안 되는 이벤트**

주문이 완료되면 여러 시스템이 알아야 합니다:
- 재고 시스템: 재고를 차감해야 함
- 결제 시스템: 실제 결제를 처리해야 함
- 배송 시스템: 배송 준비를 해야 함
- 회계 시스템: 매출을 기록해야 함

이 중 하나라도 놓치면 큰 문제! 
Redis로 하면? → 서버 재시작 시 메시지가 사라질 위험

Kafka는:
- 모든 메시지를 디스크에 영구 저장
- 서버가 죽어도 메시지는 살아있음
- 처리 실패하면 다시 시도 가능

```java
// Kafka 이벤트 발행
@Transactional
public Order createOrder(OrderRequest request) {
    Order order = orderRepository.save(new Order(request));
    
    // 이 이벤트는 절대 잃어버리면 안 됨!
    kafkaTemplate.send("order-created", OrderCreatedEvent.from(order));
    return order;
}

// Kafka 이벤트 구독
@KafkaListener(topics = "order-created")
public void handleOrderCreated(OrderCreatedEvent event) {
    // 재고 차감, 결제 처리 등
    inventoryService.decreaseStock(event.getItems());
}
```

**상황 2: 대용량 데이터를 장기간 보관**

사용자들이 어떤 상품을 클릭했는지 로그 데이터:
- 하루에 수백만 건 발생
- 지금 당장은 필요 없음 (사용자 응답에 영향 없음)
- 하지만 6개월 후 머신러닝 모델 학습에 필요
- Redis 메모리로는 감당 안 됨

Kafka는:
- 디스크 기반이라 대용량 데이터 OK
- 압축 저장으로 공간 효율적
- 원하는 기간만큼 보관 가능

**상황 3: 순서가 중요한 데이터**

사용자 계좌의 거래 내역:
1. +10만원 입금
2. -3만원 상품 구매
3. -2만원 다른 상품 구매

이 순서가 바뀌면 잔액 계산이 틀어짐!

Kafka는:
- 같은 키(사용자 ID)에 대해 순서 보장
- 파티션 단위로 순차 처리
- 메시지가 절대 순서 바뀌지 않음

### 3.2 Kafka의 한계

**문제 1: 속도가 상대적으로 느림**
- 디스크 기반이라 Redis보다 10-100배 느림
- 즉시 응답이 필요한 곳엔 부적합

**문제 2: 설정과 운영이 복잡**
- 클러스터 구성, 파티셔닝, 복제 등 고려사항 많음
- 단순한 용도엔 오버킬

**문제 3: 실시간 쿼리 불가**
- 저장은 잘하지만 복잡한 조회는 어려움
- 별도 DB나 검색 엔진 필요

## 4. 실제로는 함께 사용

### 4.1 현실적인 주문 처리 시나리오

**1단계: 사용자 요청 (Redis 활용)**
```
사용자 "주문하기" 클릭
→ Redis: 중복 클릭 확인 (0.1ms)
→ Redis: 재고 캐시 확인 (0.2ms)  
→ Redis: 사용자 세션 확인 (0.1ms)
→ 총 0.4ms 만에 즉시 검증 완료
→ "주문 접수 중..." 사용자에게 표시
```

**2단계: 핵심 데이터 저장**
```
→ DB: 주문 데이터 저장 (20ms)
→ 사용자에게 "주문 완료!" 응답 (총 30ms)
```

**3단계: 후속 처리 (Kafka 활용)**
```
→ Kafka: 주문 완료 이벤트 발행
→ 재고 시스템: 이벤트 받아서 재고 차감
→ 결제 시스템: 이벤트 받아서 실제 결제
→ 알림 시스템: 이벤트 받아서 이메일 발송
→ 분석 시스템: 이벤트 받아서 데이터 수집
```

사용자는 30ms 만에 응답받고, 나머지는 백그라운드에서 안정적으로 처리!

### 4.2 서로의 약점을 보완

**Redis의 휘발성 → Kafka의 영구성으로 보완**
- Redis: 빠른 캐시로 사용
- Kafka: 원본 데이터를 안전하게 보관
- Redis 캐시가 날아가도 Kafka에서 복구 가능

**Kafka의 느린 속도 → Redis의 속도로 보완**  
- Kafka: 모든 이벤트를 안전하게 저장
- Redis: 자주 조회되는 데이터는 캐시로 빠르게 제공

## 5. 선택 가이드: 언제 뭘 써야 하나?

### 5.1 간단한 판단 기준

**3가지 질문으로 결정하세요:**

**Q1: "사용자가 기다리고 있나?"**
- Yes → Redis 우선 고려
- No → Kafka 우선 고려

**Q2: "데이터가 사라져도 되나?"**
- Yes → Redis 가능
- No → Kafka 필수

**Q3: "순서가 중요한가?"**
- Yes → Kafka
- No → Redis 가능

### 5.2 실제 적용 예시

| 상황 | 선택 | 이유 |
|-----|------|------|
| 상품 정보 조회 | Redis | 사용자 대기, 자주 조회 |
| 주문 완료 이벤트 | Kafka | 절대 놓치면 안 됨 |
| 로그인 세션 | Redis | 빠른 확인 필요, 임시 데이터 |
| 결제 내역 | Kafka | 순서 중요, 영구 보관 |
| 실시간 채팅 | Redis | 즉시성 중요 |
| 데이터 분석 로그 | Kafka | 대용량, 장기 보관 |
| 분산 락 | Redis | 즉시 응답 필요 |
| 이벤트 소싱 | Kafka | 순서와 영구성 중요 |

## 6. 현재 프로젝트에서는 어떻게?

### 6.1 현재 상황 분석

당신의 프로젝트에서는 지금:
- **Redis**: 캐시, 분산 락으로 사용 중 ✅
- **EventLog**: DB 테이블로 이벤트 저장 중
- **ApplicationEventPublisher**: 같은 JVM 내 이벤트 처리

### 6.2 점진적 개선 방향

**1단계: Redis 활용 확대**
- 세션 관리 추가
- 실시간 카운터 (조회수, 좋아요 등)
- 임시 데이터 저장 (장바구니, 임시 저장 등)

**2단계: Kafka 부분 도입**
- 중요한 이벤트만 Kafka로 (주문, 결제 등)
- 기존 ApplicationEventPublisher와 병행 사용
- Feature Flag로 점진적 전환

```java
// 현재 프로젝트 적용 예시
@Service
public class HybridEventService {
    @Autowired private ApplicationEventPublisher springEvents;
    @Autowired private KafkaTemplate<String, Object> kafkaTemplate;
    
    public void publishEvent(DomainEvent event) {
        // 로컬 처리 (빠른 응답)
        springEvents.publishEvent(event);
        
        // 중요한 이벤트만 Kafka로도 발행 (안정성)
        if (isCriticalEvent(event)) {
            kafkaTemplate.send("critical-events", event);
        }
    }
}
```

**3단계: 완전한 이벤트 기반 아키텍처**
- 모든 도메인 이벤트를 Kafka로
- 마이크로서비스 간 통신 표준화
- 이벤트 소싱 적용

## 7. 결론

### 7.1 핵심 메시지

**Redis와 Kafka는 경쟁자가 아니라 파트너입니다.**

- Redis: "사용자가 느끼는" 성능 담당
- Kafka: "시스템이 보장하는" 안정성 담당

### 7.2 실무 팁

1. **작게 시작하세요**
   - Redis는 캐시부터
   - Kafka는 중요한 이벤트 하나부터

2. **측정하세요**
   - Redis: 응답 시간, 캐시 적중률
   - Kafka: 메시지 처리 지연, 실패율

3. **모니터링하세요**
   - Redis: 메모리 사용률, 연결 상태
   - Kafka: 컨슈머 랙, 디스크 용량

당신의 이해가 정확했습니다! Redis는 "뭐든 빠르게 잘하는 애", Kafka는 "메시징과 이벤트를 매우 확실하게 잘하는 애"입니다. 

하지만 **실제로는 둘이 협력해서 더 강력한 시스템**을 만듭니다. 사용자는 Redis의 속도를 경험하고, 시스템은 Kafka의 안정성으로 돌아갑니다.