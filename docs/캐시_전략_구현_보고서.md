# Redis 기반 캐시 전략 구현 보고서

---

## 1. 배경 및 문제 정의

### 1.1 기술적 과제
1. **Cache Stampede 현상**: 인기 상품 캐시 만료 시 동시 다발적 DB 요청
2. **데이터 일관성**: 잔액, 주문 상태 등 중요 데이터의 정합성 보장
3. **메모리 효율성**: 무제한 캐시 증가로 인한 메모리 누수
4. **계층 선택**: 캐싱 로직 적용 위치 결정 (Domain vs Repository)

---
## 2. 캐시 전략 설계

### 2.1 캐싱 계층 선정

**Service Layer를 캐싱 포인트로 선정한 이유:**

```java
@Service
@RequiredArgsConstructor
public class ProductService {
    private final CachePort cachePort;  // Domain Port 인터페이스
    private final GetProductUseCase getProductUseCase;
    
    public Product getProduct(Long productId) {
        // Service 레이어에서 캐시 처리
        String cacheKey = keyGenerator.generateProductCacheKey(productId);
        Product cached = cachePort.get(cacheKey, Product.class);
        
        if (cached != null) {
            return cached;  // Cache Hit
        }
        
        // UseCase는 순수 비즈니스 로직만 담당
        Product product = getProductUseCase.execute(productId);
        cachePort.put(cacheKey, product, CacheTTL.PRODUCT_DETAIL.getSeconds());
        
        return product;
    }
}
```

**선정 근거:**
- ✅ **Domain 순수성 유지**: UseCase는 캐시와 무관한 비즈니스 로직에 집중
- ✅ **테스트 용이성**: UseCase 단위 테스트 시 캐시 의존성 제거

### 2.2 캐시 패턴 선택

#### Cache-Aside vs Write-Through 선택 기준

| 데이터 특성             | 선택 패턴             | 근거           |
| ------------------ | ----------------- | ------------ |
| **자주 변경 + 정확성 중요** | Write-Through     | 잔액, 주문 상태    |
| **변경 빈도 낮음**       | Cache-Aside       | 상품 정보, 인기 상품 |
| **복잡한 쿼리 결과**      | Cache-Aside + 무효화 | 주문 목록, 쿠폰 목록 |

### 2.3 TTL 전략

**CacheTTL Enum 구현:**

```java
public enum CacheTTL {
    PRODUCT_DETAIL(3600),        // 1시간 - 상품 정보는 자주 변경되지 않음
    PRODUCT_LIST(3600),          // 1시간 - 목록도 동일
    ORDER_DETAIL(600),           // 10분 - 주문 상태 변경 고려
    ORDER_LIST(300),             // 5분 - 신규 주문 반영
    USER_BALANCE(60),            // 1분 - 금전 관련 정확성 우선
    USER_COUPON_LIST(300);       // 5분 - 쿠폰 발급 주기 고려
    
    private final int seconds;
    
    // 동적 TTL: 인기 상품 조회 기간에 따라 조정
    public static int getPopularProductTTLSeconds(int period) {
        if (period <= 1) return 300;    // 1일: 5분 (실시간성)
        if (period <= 3) return 600;    // 3일: 10분
        if (period <= 7) return 1800;   // 7일: 30분
        if (period <= 30) return 3600;  // 30일: 1시간
        return 7200;                     // 그 이상: 2시간
    }
}
```

---

## 3. Cache Stampede 방어 전략

### 3.1 문제 정의

Cache Stampede는 캐시가 만료되는 순간 동시에 많은 요청이 DB로 몰리는 현상.

```
시간 T0: 인기상품 캐시 만료
시간 T1: 1000개 동시 요청 → 모두 Cache Miss
시간 T2: 1000개 요청 모두 DB 조회 → DB 과부하
시간 T3: DB 응답 지연 → 전체 서비스 장애
```

### 3.2 예방 시스템 구현

#### 3.2.1 Lock 기반 예방

```java
@Component
@RequiredArgsConstructor
public class RedisCacheAdapter implements CachePort {
    private final RedissonClient redissonClient;
    
    @Override
    public <T> T get(String key, Class<T> type) {
        RBucket<T> bucket = redissonClient.getBucket(key);
        
        // 1차 시도: 캐시 확인
        T cached = bucket.get();
        if (cached != null) return cached;
        
        // 2차 시도: Lock 획득 (최대 200ms 대기)
        RLock lock = redissonClient.getLock("lock:" + key);
        try {
            if (lock.tryLock(200, TimeUnit.MILLISECONDS)) {
                try {
                    // Double-check: 다른 스레드가 이미 캐시했는지 확인
                    cached = bucket.get();
                    if (cached != null) return cached;
                    
                    // null 반환 → Service에서 DB 조회 후 put() 호출
                    return null;
                } finally {
                    lock.unlock();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Lock 획득 실패 시 재시도 메커니즘
        try {
            Thread.sleep(50);  // 짧은 대기
            cached = bucket.get();  // 재확인
            if (cached != null) return cached;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        return null;  // DB 폴백
    }
}
```

**효과:**
- ✅ 동시 요청 중 **단 하나의 스레드만** DB 조회
- ✅ Redisson의 pub/sub 메커니즘으로 **CPU 효율적**
- ✅ 200ms 타임아웃으로 **데드락 방지**

####  3.2.2 TTL Randomization

```java
@Override
public void put(String key, Object value, int ttlSeconds) {
    RBucket<Object> bucket = redissonClient.getBucket(key);
    
    if (ttlSeconds > 0) {
        // ±10% 랜덤 지터 추가
        Random random = new Random();
        int jitter = (int) (ttlSeconds * 0.1 * (random.nextDouble() * 2 - 1));
        int randomizedTTL = Math.max(1, ttlSeconds + jitter);
        
        bucket.set(value, randomizedTTL, TimeUnit.SECONDS);
        
        log.debug("캐시 저장: key={}, originalTTL={}, randomizedTTL={}", 
                  key, ttlSeconds, randomizedTTL);
    } else {
        bucket.set(value);  // TTL 없이 저장
    }
}
```

**효과:**
- ✅ 동시 만료 방지로 **부하 분산**
- ✅ 자연스러운 캐시 갱신 **시점 분산**
- ✅ 추가 코드 없이 **자동 적용**

### 3.3 적용 결과

```java
// ProductService에서의 실제 사용
public List<Product> getPopularProductList(int period, int limit, int offset) {
    String cacheKey = keyGenerator.generatePopularProductsCacheKey(period);
    
    // Cache Stampede 방어가 내장된 get() 호출
    List<Product> cached = cachePort.getList(cacheKey);
    
    if (cached != null) {
        log.info("인기상품 Cache Hit: period={}", period);
        return cached;
    }
    
    // 단 하나의 스레드만 여기 도달
    log.info("인기상품 Cache Miss - DB 조회: period={}", period);
    List<Product> products = getPopularProductListUseCase.execute(period, limit, offset);
    
    // TTL Randomization이 자동 적용되는 put() 호출
    int ttl = CacheTTL.getPopularProductTTLSeconds(period);
    cachePort.put(cacheKey, products, ttl);
    
    return products;
}
```

---

## 4. Write-Through 패턴 구현

### 4.1 적용 대상 선정

**Write-Through가 적합한 케이스:**

```java
@Service
@RequiredArgsConstructor
public class BalanceService {
    
    @Transactional
    public Balance chargeBalance(Long userId, BigDecimal amount) {
        // 1. 비즈니스 로직 실행
        Balance result = transactionTemplate.execute(status -> {
            return chargeBalanceUseCase.execute(userId, amount);
        });
        
        // 2. Write-Through: 새 데이터를 즉시 캐시에 저장
        String cacheKey = keyGenerator.generateBalanceCacheKey(userId);
        cachePort.put(cacheKey, result, CacheTTL.USER_BALANCE.getSeconds());
        
        log.info("잔액 충전 완료 - Write-Through 캐시 갱신: userId={}", userId);
        
        return result;
    }
}
```

**장점:**
- ✅ 다음 조회 시 **100% Cache Hit 보장**
- ✅ **불필요한 DB 조회 제거**
- ✅ **데이터 일관성** 향상

### 4.2 혼합 전략 적용

**OrderService - 개별 캐시는 Write-Through, 목록 캐시는 무효화:**

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    
    @Transactional
    public Order createOrder(Long userId, List<ProductQuantity> items) {
        // 1. 주문 생성
        Order order = transactionTemplate.execute(status -> {
            return createOrderUseCase.execute(userId, items);
        });
        
        // 2. Write-Through: 생성된 주문을 캐시에 저장
        String orderKey = keyGenerator.generateOrderCacheKey(order.getId());
        cachePort.put(orderKey, order, CacheTTL.ORDER_DETAIL.getSeconds());
        
        // 3. Cache-Aside: 주문 목록은 무효화 (페이징 복잡성)
        String pattern = keyGenerator.generateOrderListCachePattern(userId);
        cachePort.evictByPattern(pattern);
        
        return order;
    }
    
    @Transactional
    public Payment payOrder(Long orderId, Long userId, Long couponId) {
        // 1. 결제 처리
        Payment payment = transactionTemplate.execute(status -> {
            return payOrderUseCase.execute(orderId, userId, couponId);
        });
        
        // 2. Write-Through: 변경된 주문 상태를 캐시에 반영
        Order updatedOrder = getOrderUseCase.execute(userId, orderId)
            .orElseThrow(() -> new OrderException.NotFound());
        
        String orderKey = keyGenerator.generateOrderCacheKey(orderId);
        cachePort.put(orderKey, updatedOrder, CacheTTL.ORDER_DETAIL.getSeconds());
        
        // 3. 주문 목록 무효화
        String pattern = keyGenerator.generateOrderListCachePattern(userId);
        cachePort.evictByPattern(pattern);
        
        return payment;
    }
}
```

---
